<?PHP 
code::init();
code::initFunction("Insere(No,Info)");

code::l("indice : inteiro;", "Declarando variável para leitura");
code::l("indice := 0;", "Declarando variável para leitura");
code::l();
code::l("Enquanto indice != ORDEM e No.info[i] != nulo então", "Percorrendo array de valores do nó");
code::begin();
    code::l("Se No.info[i] == info então", "Se o valor do elemento for igual da inserção");
    code::begin();
        code::l("Retornar", "Inserção se encerra");
    code::end();
    code::l("Senão se No.info[i] > info então", "Se o valor do elemento for maior que o valor da inserção");
    code::begin();
        code::l("Se No.filho[i] != nulo então", "Se possuir um filho na posição 'i'");
        code::begin();
            code::l("Insere(No.filho[i],info);", "Pesquisa continua no filho 'i'");
            code::l("Retornar", "Inserção se encerra");
        code::end();
        code::l("Senão", "Senão possuir filho para continuar a pesquisa");
        code::begin();
            code::l("Break;", "Pesquisa se encerra, a inserção será neste nó");
        code::end();
    code::end();
code::end();
code::l();
code::l("Se No.filho[i] != nulo então", "Se existir um filho da posição 'i', ou seja, na última posição");
code::begin();
    code::l("Insere(No.filho[i],info);", "Inserção continua no último nó filho");
code::end();
code::l("Senão", "Se não existir um filho da posição 'i', inicia a inserção");
code::begin();
    code::l("Se No.info[i] != nulo então", "Se houver espaço livre no elemento");
    code::begin();
        code::l("i : inteiro;", "Declarando váriavel para leitura");
        code::l("i := No.qtd;", "Posicionando leitura no último elemento do nó");
        code::l();
        code::l("Enquanto i != indice então", "Percorrendo elementos do nó, de frente para trás");
        code::begin();
            code::l("No.info[i] := No.info[i-1];", "Deslocando elementos para a próxima posição");
            code::l("i := i-1;", "Decrementando váriavel de leitura");
        code::end();
    code::end();
    code::l();
    code::l("No.info[indice] := info;", "Inserindo o novo elemento");
    code::l("No.qtd := No.qtd + 1;", "Incrementando contador que representa o total de elementos inseridos no nó");
    code::l();
    code::l("Se No.qtd == ORDEM então", "Se o nó estiver completo, realiza-se o split");
    code::begin();
        code::l("Se No.pai == nulo então", "Se o nó for o primeiro nó da árvore");
        code::begin();
            code::l("SplitDown(No);", "A árvore quebrasse a baixo");
        code::end();
        code::l("Senão", "Se o nó não for o primeiro nó da árvore");
        code::begin();
            code::l("SplitUp(No,info);", "A árvore joga o elemento intermediário acima, e o nó é repartido ao meio");
        code::end();
    code::end();
code::end();

code::write();

code::initFunction("SplitDown(No)");

code::l("meio , meiofilhos : inteiro;", "Declarando variáveis");
code::l("firstno , secondno : EstruturaB;", "Declarando novos nós");
code::l("meio := ORDEM/2;", "Obtendo a posição central do nó");
code::l("meiofilhos := (ORDEM+1)/2;", "Obtendo a quantidade de filhos para os novos nó");
code::l("firstno := alocar();", "Alocando novo nó á esquerda");
code::l("secondno := alocar();", "Alocando novo nó á direita");
code::l("firstno.pai := No;", "Definindo pai do novo nó á esquerda");
code::l("secondno.pai := No;", "Definindo pai do novo nó á direita");
code::l();
code::l("No.qtdfilhos != 0 então", "Se não for o primeiro Split, ou seja, o nó a ser dividido possuir filhos");
code::begin();
    code::l("Para i : inteiro de 0 até ORDEM + 1 passo 1 faça", "Percorrendo filhos");
    code::begin();
        code::l("Se i < meiofilhos faça", "Se a posição do filho for menor que a posição central");
        code::begin();
            code::l("firstno.filho[i] := No.filho[i];", "Novo nó á esquerda recebe o filho na posição 'i'");
            code::l("firstno.qtdfilhos := firstno.qtdfilhos + 1;","Incrementa a quantidade de filhos no novo nó á esquerda");
            code::l("No.filho[i].pai := firstno;", "Filho na posição 'i' agora aponta para o novo nó á esquerda");
        code::end();
        code::l("Senão", "Se a posição do filho for maior que a posição central");
        code::begin();
            code::l("secondno.filho[i-meiofilhos] := No.filho[i];", "Novo nó á direita recebe o filho na posição 'i'");
            code::l("secondno.qtdfilhos := secondno.qtdfilhos + 1;","Incrementa a quantidade de filhos no novo nó á direita");
            code::l("No.filho[i].pai := secondno;", "Filho na posição 'i' agora aponta para o novo nó á direita");
        code::end();
        code::l("No.filho[i] := nulo;", "Pointeiro removido, pois o filho já foi transferido para o novo nó");
    code::end();
code::end();
code::l();
code::l("i : inteiro;", "Declarando variável para leitura dos elementos");
code::l("i := 0;", "Posicionando váriavel na primeira posição");
code::l();
code::l("Enquanto i < meio então", "Percorrendo posições dos elementos até o elemento intermediário");
code::begin();
    code::l("firstno.info[i] := No.info[i];", "Transferindo o elemento para o novo nó á esquerda");
    code::l("No.info[i] := nulo;", "Pointeiro removido, pois o elemento já foi transferido para o novo nó");
    code::l("firstno.qtd := firstno.qtd + 1;","Incrementa a quantidade de elementos no novo nó á esquerda");
    code::l("i := i + 1;", "incrementando váriavel de leitura para a posição do próximo elemento");
code::end();
code::l();
code::l("i := i + 1;", "Posicionando variável de leitura para a posição do elemento após o elemento intermediário");
code::l();
code::l("Enquanto i < ORDEM então", "Percorrendo posições de elementos após a posição do elemento intermediário");
code::begin();
    code::l("secondno.info[i-meio-1] := No.info[i];", "Transferindo o elemento para as primeiras posições do novo nó á direita");
    code::l("No.info[i] := nulo;", "Pointeiro removido, pois o elemento já foi transferido para o novo nó");
    code::l("secondno.qtd := secondno.qtd + 1;","Incrementa a quantidade de elementos no novo nó á direita");
    code::l("i := i + 1;", "incrementando váriavel de leitura para a posição do próximo elemento");
code::end();
code::l();
code::l("No.filho[0] := firstno;", "Nó aponta aponta para o novo nó a esquerda");
code::l("No.filho[1] := secondno;", "Nó aponta aponta para o novo nó a direita");
code::l("No.info[0] := No.info[meio];", "Desalocando o elemento na posição intermediária para a primeira posição");
code::l("No.info[meio] := nulo;", "Removendo pointeiro do elemento, pois o elemento já foi deslocado");
code::l("No.qtd := 1;", "Definindo a quantidade de elementos do nó");
code::l("No.qtdfilhos := 2;", "Definindo a quantidade de filhos do nó");
code::write();

code::initFunction("SplitUp(No)");

code::l("meio,pos,valor,j : inteiro;","Declarando variáveis do tipo inteiro");
code::l("Pai,novo : EstruturaB;","Delclrando variáveis do tipo estruturado EstruturaB");
code::l("meio := ORDEM/2;","Obtendo posição do elemento intermediário");
code::l("pos := 0;","Posicionando o leitor no inicio");
code::l("Pai := No.pai;","Armazendo o ponteiro pai");
code::l();
code::l("Enquanto Pai.info[pos] < No.campos[0] então", "Recuperando posição do filho no nó pai");
code::begin();
    code::l("pos := pos + 1;", "Incrementando variável");
code::end();
code::l();
code::l("j := Pai.qtd;","Posicionando leitor");
code::l();
code::l("Enquanto j > pos faça","Percorrendo de trás para frente até a posição do filho no nó pai");
code::begin();
    code::l("Pai.info[j] := Pai.info[j-1];","Deslocando elemento na posicao 'j' para direita");
    code::l("Pai.filho[j+1] := Pai.filho[j];","Deslocando filho na posicao 'j' para direita");
    code::l("j := j - 1;","decrementando indice");
code::end();
code::l();
code::l("Pai.filho[j+1] := Pai.filho[j];", "Deslocando filho na posicao 'j' para direita");
code::l("novo := alocar();", "Alocando o novo nó");
code::l("Pai.filho[pos] := novo;", "Pai aponta para o novo elemento");
code::l("Pai.info[pos] := No.info[mid];", "Elemento na posição intermediária é transferido para o pai");
code::l("No.info[mid] := nulo;", "Removendo pointeiro, pois elemento já foi transferido para o pai");
code::l("Se No.qtdfilhos != 0 então", "Verificando se o nó possui filhos");
code::begin();
    code::l("meiofilhos,i : inteiro;", "Declarando variáveis");
    code::l("meiofilhos := (ORDEM+1)/2;", "Recuperando quantidade de filhos a serem transferidos");
    code::l("i := 0;", "Posicionando variável no inicio");
    code::l("Enquanto i != meiofilhos então","Percorrendo posições de filhos até o meio");
    code::begin();
        code::l("novo.filho[i] := no.filho[i];","Tranferindo filho para o novo nó");
        code::l("No.filho[i] := nulo;","Removendo ponteiro pois o filho já foi transferido");
        code::l("No.qtdfilhos := No.qtdfilhos - 1;","Decrementando o número de filhos no nó");
        code::l("novo.qtdfilhos := novo.qtdfilhos + 1;","Incrementando o número de filhos no novo nó");
        code::l("i := i + 1;","Incrementando indice");
    code::end();
    code::l("Enquanto i <= ORDEM então", "Percorrendo posições dos filhos do meio até o fim");
    code::begin();
        code::l("No.filho[i-meiofilhos] := No.filho[i];","Deslocando filho para as posições iniciais");
        code::l("No.filho[i] := nulo;","Removendo pointeiro pois o filho já foi transferido");
        code::l("i := i + 1;","Incrementando indice");
    code::end();
code::end();
code::l();
code::l("i : inteiro;", "Declarando variável para leitura");
code::l("i := 0;", "Posicionando variável no primeiro indice");
code::l();
code::l("Enquanto i != meio então", "Percorrendo até o elemento intermediário");
code::begin();
    code::l("novo.info[i] := No.info[i];", "Transferindo elemento na posição 'i' para o novo nó");
    code::l("No.info[i] := nulo;", "Removendo pointeiro, pois o elemento já foi transferido");
    code::l("No.qtd = No.qtd - 1;", "Decrementando quantidade de elementos no nó");
    code::l("novo.qtd = novo.qtd + 1;", "Incrementando quantidade de elementos no nó");
    code::l("i := i + 1;", "Incrementando indice");
code::end();
code::l("i := 0;", "Reiniciando indice");
code::l("Enquanto i != meio então", "Percorrendo até o elemento intermediário");
code::begin();
    code::l("No.info[i] := No.info[i+meio+1];", "Deslocando elemento para posições iniciais");
    code::l("No.info[i+meio+1] := nulo;", "Removendo pointeiro, pois o elemento já foi transferido");
    code::l("i := i + 1;", "Incrementando indice");
code::end();
code::l();
code::l("Pai.qtd := Pai.qtd + 1;", "Incrementando total de elementos no nó pai");
code::l("Pai.qtdfilhos := Pai.qtdfilhos + 1;","Incrementando total de filhos no nó pai");
code::l();
code::l("Se Pai.qtd == ORDEM então","Se o nó estiver cheio, logo após o Split");
code::begin();
    code::l("Se Pai.pai != nulo então","Se o nó pai possuir um nó pai");
    code::begin();
        code::l("SplitUp(Pai);", "Outro Split pra cima é realizado no nó pai");
    code::end();
    code::l("Senão","Se o nó pai não possuir um nó pai");
    code::begin();
        code::l("SplitDown(Pai);", "Um split para baixo é realizado no nó pai");
    code::end();
code::end();

code::write();
